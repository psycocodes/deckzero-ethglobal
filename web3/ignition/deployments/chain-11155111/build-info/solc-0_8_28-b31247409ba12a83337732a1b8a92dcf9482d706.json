{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-b31247409ba12a83337732a1b8a92dcf9482d706",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/KeynesianBeautyContest.sol": "project/contracts/KeynesianBeautyContest.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/KeynesianBeautyContest.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title KeynesianBeautyContest\r\n * @dev A multiplayer game contract implementing the Keynesian Beauty Contest\r\n */\r\ncontract KeynesianBeautyContest {\r\n    \r\n    // Game states\r\n    enum GameState { Created, InProgress, Ended }\r\n    \r\n    // Player data structure\r\n    struct Player {\r\n        address playerAddress;\r\n        int256 score;\r\n        bool isEliminated;\r\n    }\r\n    \r\n    // Game data structure\r\n    struct Game {\r\n        uint256 gameId;\r\n        uint256 entryFee;\r\n        uint8 maxPlayers;\r\n        uint8 currentPlayers;\r\n        GameState state;\r\n        address[] players;\r\n        mapping(address => Player) playerData;\r\n        mapping(address => bool) hasJoined;\r\n        bool rule1Active;\r\n        bool rule2Active;\r\n        bool rule3Active;\r\n        uint256 currentRound;\r\n        address gameCoordinator;\r\n    }\r\n    \r\n    // Storage\r\n    mapping(uint256 => Game) public games;\r\n    uint256 public nextGameId;\r\n    \r\n    // Events\r\n    event GameCreated(uint256 indexed gameId, address indexed creator, uint256 entryFee, uint8 maxPlayers);\r\n    event PlayerJoined(uint256 indexed gameId, address indexed player);\r\n    event RoundSettled(uint256 indexed gameId, uint256 indexed roundNo, address indexed winner);\r\n    event PlayerEliminated(uint256 indexed gameId, address indexed player);\r\n    event GameClear(uint256 indexed gameId, address indexed winner);\r\n    event RuleUnlocked(uint256 indexed gameId, uint8 ruleNumber);\r\n    \r\n    // Modifiers\r\n    modifier gameExists(uint256 gameId) {\r\n        require(gameId < nextGameId, \"Game does not exist\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyGameCoordinator(uint256 gameId) {\r\n        require(msg.sender == games[gameId].gameCoordinator, \"Only game coordinator can call this function\");\r\n        _;\r\n    }\r\n    \r\n    modifier gameInProgress(uint256 gameId) {\r\n        require(games[gameId].state == GameState.InProgress, \"Game is not in progress\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Creates a new game with specified parameters\r\n     * @param entryFee The fee required to join the game (in wei)\r\n     * @param maxPlayers Maximum number of players allowed in the game\r\n     */\r\n    function createGame(uint256 entryFee, uint8 maxPlayers) external returns (uint256) {\r\n        require(maxPlayers > 1, \"Game must allow at least 2 players\");\r\n        require(maxPlayers <= 50, \"Too many players\"); // Reasonable limit\r\n        \r\n        uint256 gameId = nextGameId++;\r\n        Game storage newGame = games[gameId];\r\n        \r\n        newGame.gameId = gameId;\r\n        newGame.entryFee = entryFee;\r\n        newGame.maxPlayers = maxPlayers;\r\n        newGame.currentPlayers = 0;\r\n        newGame.state = GameState.Created;\r\n        newGame.rule1Active = false;\r\n        newGame.rule2Active = false;\r\n        newGame.rule3Active = false;\r\n        newGame.currentRound = 0;\r\n        newGame.gameCoordinator = msg.sender;\r\n        \r\n        emit GameCreated(gameId, msg.sender, entryFee, maxPlayers);\r\n        \r\n        return gameId;\r\n    }\r\n    \r\n    /**\r\n     * @dev Allows a player to join an existing game\r\n     * @param gameId The ID of the game to join\r\n     */\r\n    function joinGame(uint256 gameId) external payable gameExists(gameId) {\r\n        Game storage game = games[gameId];\r\n        \r\n        require(game.state == GameState.Created, \"Game is not accepting new players\");\r\n        require(game.currentPlayers < game.maxPlayers, \"Game is full\");\r\n        require(!game.hasJoined[msg.sender], \"Player already joined this game\");\r\n        require(msg.value == game.entryFee, \"Incorrect entry fee\");\r\n        \r\n        // Add player to the game\r\n        game.players.push(msg.sender);\r\n        game.playerData[msg.sender] = Player({\r\n            playerAddress: msg.sender,\r\n            score: 0,\r\n            isEliminated: false\r\n        });\r\n        game.hasJoined[msg.sender] = true;\r\n        game.currentPlayers++;\r\n        \r\n        // Start the game if it's full\r\n        if (game.currentPlayers == game.maxPlayers) {\r\n            game.state = GameState.InProgress;\r\n        }\r\n        \r\n        emit PlayerJoined(gameId, msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * @dev Settles a round with results from the game coordinator\r\n     * @param gameId The ID of the game\r\n     * @param roundNo The round number being settled\r\n     * @param winner The address of the round winner\r\n     * @param scoreUpdates Array of score changes for all players (in player order)\r\n     * @param newRule New rule that got unlocked (0 = no new rule, 1-3 = rule number)\r\n     */\r\n    function settleRound(\r\n        uint256 gameId,\r\n        uint256 roundNo,\r\n        address winner,\r\n        int256[] memory scoreUpdates,\r\n        uint8 newRule\r\n    ) external gameExists(gameId) onlyGameCoordinator(gameId) gameInProgress(gameId) {\r\n        Game storage game = games[gameId];\r\n        \r\n        require(roundNo == game.currentRound + 1, \"Invalid round number\");\r\n        require(scoreUpdates.length == game.players.length, \"Score updates length mismatch\");\r\n        require(game.hasJoined[winner], \"Winner is not a player in this game\");\r\n        require(!game.playerData[winner].isEliminated, \"Winner cannot be eliminated\");\r\n        \r\n        // Update scores and check for eliminations\r\n        for (uint256 i = 0; i < game.players.length; i++) {\r\n            address playerAddr = game.players[i];\r\n            Player storage player = game.playerData[playerAddr];\r\n            \r\n            if (!player.isEliminated) {\r\n                player.score += scoreUpdates[i];\r\n                \r\n                // Check if player should be eliminated (score <= -100 for example)\r\n                if (player.score <= -100) {\r\n                    player.isEliminated = true;\r\n                    emit PlayerEliminated(gameId, playerAddr);\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Update round number\r\n        game.currentRound = roundNo;\r\n        \r\n        // Handle new rule unlocking\r\n        if (newRule == 1 && !game.rule1Active) {\r\n            game.rule1Active = true;\r\n            emit RuleUnlocked(gameId, 1);\r\n        } else if (newRule == 2 && !game.rule2Active) {\r\n            game.rule2Active = true;\r\n            emit RuleUnlocked(gameId, 2);\r\n        } else if (newRule == 3 && !game.rule3Active) {\r\n            game.rule3Active = true;\r\n            emit RuleUnlocked(gameId, 3);\r\n        }\r\n        \r\n        emit RoundSettled(gameId, roundNo, winner);\r\n    }\r\n    \r\n    /**\r\n     * @dev Ends the game and declares a winner\r\n     * @param gameId The ID of the game to end\r\n     */\r\n    function endGame(uint256 gameId) external gameExists(gameId) onlyGameCoordinator(gameId) gameInProgress(gameId) {\r\n        Game storage game = games[gameId];\r\n        \r\n        // Find the winner (player with highest score who is not eliminated)\r\n        address winner;\r\n        int256 highestScore = type(int256).min;\r\n        \r\n        for (uint256 i = 0; i < game.players.length; i++) {\r\n            address playerAddr = game.players[i];\r\n            Player storage player = game.playerData[playerAddr];\r\n            \r\n            if (!player.isEliminated && player.score > highestScore) {\r\n                highestScore = player.score;\r\n                winner = playerAddr;\r\n            }\r\n        }\r\n        \r\n        require(winner != address(0), \"No valid winner found\");\r\n        \r\n        // End the game\r\n        game.state = GameState.Ended;\r\n        \r\n        // Transfer prize pool to winner (total entry fees)\r\n        uint256 prizePool = game.entryFee * game.currentPlayers;\r\n        payable(winner).transfer(prizePool);\r\n        \r\n        emit GameClear(gameId, winner);\r\n    }\r\n    \r\n    /**\r\n     * @dev Gets player information for a specific game\r\n     * @param gameId The ID of the game\r\n     * @param playerAddr The address of the player\r\n     */\r\n    function getPlayerInfo(uint256 gameId, address playerAddr) external view gameExists(gameId) returns (int256 score, bool isEliminated) {\r\n        require(games[gameId].hasJoined[playerAddr], \"Player is not in this game\");\r\n        Player storage player = games[gameId].playerData[playerAddr];\r\n        return (player.score, player.isEliminated);\r\n    }\r\n    \r\n    /**\r\n     * @dev Gets game information\r\n     * @param gameId The ID of the game\r\n     */\r\n    function getGameInfo(uint256 gameId) external view gameExists(gameId) returns (\r\n        uint256 entryFee,\r\n        uint8 maxPlayers,\r\n        uint8 currentPlayers,\r\n        GameState state,\r\n        bool rule1Active,\r\n        bool rule2Active,\r\n        bool rule3Active,\r\n        uint256 currentRound,\r\n        address gameCoordinator\r\n    ) {\r\n        Game storage game = games[gameId];\r\n        return (\r\n            game.entryFee,\r\n            game.maxPlayers,\r\n            game.currentPlayers,\r\n            game.state,\r\n            game.rule1Active,\r\n            game.rule2Active,\r\n            game.rule3Active,\r\n            game.currentRound,\r\n            game.gameCoordinator\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @dev Gets the list of players in a game\r\n     * @param gameId The ID of the game\r\n     */\r\n    function getGamePlayers(uint256 gameId) external view gameExists(gameId) returns (address[] memory) {\r\n        return games[gameId].players;\r\n    }\r\n    \r\n    /**\r\n     * @dev Gets the number of active (non-eliminated) players in a game\r\n     * @param gameId The ID of the game\r\n     */\r\n    function getActivePlayersCount(uint256 gameId) external view gameExists(gameId) returns (uint256) {\r\n        Game storage game = games[gameId];\r\n        uint256 activeCount = 0;\r\n        \r\n        for (uint256 i = 0; i < game.players.length; i++) {\r\n            if (!game.playerData[game.players[i]].isEliminated) {\r\n                activeCount++;\r\n            }\r\n        }\r\n        \r\n        return activeCount;\r\n    }\r\n    \r\n    /**\r\n     * @dev Emergency function to withdraw contract balance (only for stuck funds)\r\n     */\r\n    function emergencyWithdraw() external {\r\n        // This should only be used if there are stuck funds due to failed transfers\r\n        // In a production environment, this should have proper access control\r\n        require(msg.sender == address(this), \"Only contract can call this\");\r\n    }\r\n}\r\n"
      }
    }
  }
}